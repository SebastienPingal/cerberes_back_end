name: AWS Deployment Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    branches: [master]
    types:
      - completed

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Debug step to check secrets are available (values will be masked)
      - name: Debug Secret Presence
        run: |
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then 
            echo "AWS_ACCESS_KEY_ID is set ‚úÖ"
          else
            echo "AWS_ACCESS_KEY_ID is NOT set ‚ùå"
          fi
          
          if [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then 
            echo "AWS_SECRET_ACCESS_KEY is set ‚úÖ"
          else
            echo "AWS_SECRET_ACCESS_KEY is NOT set ‚ùå"  
          fi
          
          if [ -n "${{ secrets.AWS_REGION }}" ]; then 
            echo "AWS_REGION is set ‚úÖ"
          else
            echo "AWS_REGION is NOT set ‚ùå"
          fi
          
          if [ -n "${{ secrets.JWT_SECRET }}" ]; then 
            echo "JWT_SECRET is set ‚úÖ"
          else
            echo "JWT_SECRET is NOT set ‚ùå"
            echo "‚ö†Ô∏è JWT_SECRET is required for the application to function properly"
          fi
          
          if [ -n "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then 
            echo "EC2_SSH_PRIVATE_KEY is set ‚úÖ"
            # Check if the key starts with the correct format
            if [[ "${{ secrets.EC2_SSH_PRIVATE_KEY }}" == "-----BEGIN"* ]]; then
              echo "SSH key appears to be in the correct format ‚úÖ"
            else
              echo "SSH key does not start with '-----BEGIN' - may be incorrectly formatted ‚ùå"
            fi
          else
            echo "EC2_SSH_PRIVATE_KEY is NOT set ‚ùå"
          fi

      # Build the app directly instead of trying to download an artifact
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8.6.0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Build application
        run: pnpm build

      - name: Prepare for production
        run: |
          # Prune development dependencies to keep only production dependencies
          echo "üì¶ Pruning dependencies for production..."
          pnpm prune --prod

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create terraform.tfvars
        run: |
          cat > terraform/terraform.tfvars << EOF
          aws_region      = "${{ secrets.AWS_REGION }}"
          app_name        = "cerberes"
          db_username     = "${{ secrets.DB_USERNAME }}"
          db_password     = "${{ secrets.DB_PASSWORD }}"
          ssh_key_name    = "${{ secrets.SSH_KEY_NAME }}"
          ec2_instance_type = "t2.micro"
          db_instance_class = "db.t3.micro"
          EOF
          
          echo "üîë Created terraform.tfvars with database credentials"

      # Check for existing resources and modify Terraform code accordingly
      - name: Check for existing resources
        id: check-resources
        run: |
          # Get the default VPC ID for security group checks
          DEFAULT_VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query "Vpcs[0].VpcId" --output text)
          echo "DEFAULT_VPC_ID=$DEFAULT_VPC_ID" >> $GITHUB_ENV
          
          # Check if we have existing VPCs
          VPC_COUNT=$(aws ec2 describe-vpcs --query "length(Vpcs)" --output text)
          
          if [ "$VPC_COUNT" -gt "0" ]; then
            echo "VPC_EXISTS=true" >> $GITHUB_ENV
            echo "‚úÖ VPCs exist - will use existing ones"
            sed -i '/data "aws_vpcs" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/main.tf
          else
            echo "VPC_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï No VPCs exist - will use default VPC"
          fi
          
          # Get EC2 security group ID
          EC2_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=cerberes-ec2-sg" "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
          if [ "$EC2_SG_ID" != "None" ]; then
            echo "EC2_SG_EXISTS=true" >> $GITHUB_ENV
            echo "EC2_SG_ID=$EC2_SG_ID" >> $GITHUB_ENV
            echo "‚úÖ EC2 Security Group exists - will use existing one: $EC2_SG_ID"
            # Instead of modifying count, pass the ID as a variable
            echo "TF_VAR_existing_ec2_sg_id=$EC2_SG_ID" >> $GITHUB_ENV
            echo "existing_ec2_sg_id=\"$EC2_SG_ID\"" >> terraform/terraform.auto.tfvars
          else
            echo "EC2_SG_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï EC2 Security Group does not exist - will create new one"
            echo "TF_VAR_existing_ec2_sg_id=" >> $GITHUB_ENV
            echo "existing_ec2_sg_id=\"\"" >> terraform/terraform.auto.tfvars
          fi
          
          # Get RDS security group ID and update its rules
          RDS_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=cerberes-db-sg" "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
          if [ "$RDS_SG_ID" != "None" ]; then
            echo "DB_SG_EXISTS=true" >> $GITHUB_ENV
            echo "DB_SG_ID=$RDS_SG_ID" >> $GITHUB_ENV
            echo "‚úÖ DB Security Group exists - will use existing one: $RDS_SG_ID"
            # Instead of modifying count, pass the ID as a variable
            echo "TF_VAR_existing_db_sg_id=$RDS_SG_ID" >> $GITHUB_ENV
            echo "existing_db_sg_id=\"$RDS_SG_ID\"" >> terraform/terraform.auto.tfvars
            
            # Check if the EC2 security group rule exists and add it if needed
            if [ "$EC2_SG_ID" != "None" ]; then
              RULE_EXISTS=$(aws ec2 describe-security-groups --group-id $RDS_SG_ID --query "SecurityGroups[0].IpPermissions[?FromPort==\`5432\` && ToPort==\`5432\` && contains(UserIdGroupPairs[*].GroupId, \`$EC2_SG_ID\`)].FromPort" --output text)
              
              if [ -z "$RULE_EXISTS" ]; then
                echo "üîß Adding EC2 security group to RDS ingress rules..."
                aws ec2 authorize-security-group-ingress \
                  --group-id $RDS_SG_ID \
                  --protocol tcp \
                  --port 5432 \
                  --source-group $EC2_SG_ID
                echo "‚úÖ Added EC2 security group to RDS ingress rules"
              else
                echo "‚úÖ RDS security group already allows access from EC2"
              fi
            fi
          else
            echo "DB_SG_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï DB Security Group does not exist - will create new one"
            echo "TF_VAR_existing_db_sg_id=" >> $GITHUB_ENV
            echo "existing_db_sg_id=\"\"" >> terraform/terraform.auto.tfvars
          fi
          
          # Check if EC2 instances with the tag Name=cerberes-instance exist
          EC2_COUNT=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=cerberes-instance" "Name=instance-state-name,Values=running,stopped" --query "length(Reservations[*].Instances[*])" --output text)
          
          if [ "$EC2_COUNT" -gt "0" ]; then
            echo "EC2_INSTANCE_EXISTS=true" >> $GITHUB_ENV
            EC2_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=cerberes-instance" "Name=instance-state-name,Values=running,stopped" --query "Reservations[0].Instances[0].InstanceId" --output text)
            echo "‚úÖ EC2 Instance exists - will use existing one: $EC2_ID"
            # Modify the Terraform code to use the existing EC2 instance
            sed -i '/data "aws_instances" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/ec2.tf
          else
            echo "EC2_INSTANCE_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï EC2 Instance does not exist - will create new one"
          fi
          
          # Check if DB subnet group exists
          if aws rds describe-db-subnet-groups --db-subnet-group-name cerberes-db-subnet-group &> /dev/null; then
            echo "SUBNET_GROUP_EXISTS=true" >> $GITHUB_ENV
            echo "‚úÖ DB Subnet Group exists - will use existing one"
            # Modify the Terraform code to use the existing subnet group
            sed -i '/data "aws_db_subnet_group" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/rds.tf
          else
            echo "SUBNET_GROUP_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï DB Subnet Group does not exist - will create new one"
          fi
          
          # Check if DB instance exists
          if aws rds describe-db-instances --db-instance-identifier cerberes-db &> /dev/null; then
            echo "DB_INSTANCE_EXISTS=true" >> $GITHUB_ENV
            echo "‚úÖ DB Instance exists - will use existing one"
            # Modify the Terraform code to use the existing DB instance
            sed -i '/data "aws_db_instance" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/rds.tf
          else
            echo "DB_INSTANCE_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï DB Instance does not exist - will create new one"
          fi

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Debug Terraform Variables
        working-directory: ./terraform
        run: |
          echo "üîç Checking terraform.auto.tfvars content:"
          cat terraform.auto.tfvars || echo "File not found"
          
          echo "üîç Environment variables for Terraform:"
          echo "TF_VAR_existing_ec2_sg_id: $TF_VAR_existing_ec2_sg_id"
          echo "TF_VAR_existing_db_sg_id: $TF_VAR_existing_db_sg_id"

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        id: terraform-apply
        working-directory: ./terraform
        run: terraform apply -auto-approve tfplan

      # Get EC2 public IP directly from AWS CLI instead of Terraform output
      - name: Get EC2 public IP
        if: steps.terraform-apply.outcome == 'success'
        id: ec2_ip
        run: |
          # Get the EC2 instance ID
          EC2_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=cerberes-instance" "Name=instance-state-name,Values=running" --query "Reservations[0].Instances[0].InstanceId" --output text)
          
          # Get the public IP directly from AWS CLI
          IP_ADDRESS=$(aws ec2 describe-instances --instance-ids $EC2_ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          
          # Set the environment variable for use in subsequent steps
          echo "EC2_IP=$IP_ADDRESS" >> $GITHUB_ENV
          
          echo "üñ•Ô∏è EC2 instance public IP: $IP_ADDRESS"

      # Get RDS endpoint directly from AWS CLI instead of Terraform output
      - name: Get RDS endpoint
        if: steps.terraform-apply.outcome == 'success'
        id: rds_endpoint
        run: |
          # Get the RDS endpoint directly from AWS CLI
          DB_ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier cerberes-db --query "DBInstances[0].Endpoint.Address" --output text)
          
          # Set the environment variable for use in subsequent steps
          echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_ENV
          
          echo "üóÑÔ∏è RDS endpoint: $DB_ENDPOINT"

      # Add a delay to ensure EC2 instance is fully initialized
      - name: Wait for EC2 instance to initialize
        if: steps.terraform-apply.outcome == 'success'
        run: |
          echo "‚è≥ Waiting 60 seconds for EC2 instance to fully initialize..."
          sleep 60

      # Create a temporary SSH key file
      - name: Setup SSH key
        if: steps.terraform-apply.outcome == 'success'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          echo "üîë SSH key file created"
          
          # Test SSH connection
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} "echo SSH connection test successful"

      - name: Deploy application to EC2
        if: steps.terraform-apply.outcome == 'success'
        run: |
          # Create .env file for deployment
          cat > .env << EOF
          NODE_ENV=production
          DATABASE_URL=postgres://${{ secrets.DB_USERNAME }}:${{ secrets.DB_PASSWORD }}@${{ env.DB_ENDPOINT }}/cerberes
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          PORT=3000
          EOF
          
          # Create app directory on the server if it doesn't exist
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} "mkdir -p /home/ubuntu/app"
          
          echo "üßπ Cleaning up old files on server to free space..."
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} "rm -rf /home/ubuntu/app/node_modules /home/ubuntu/app/dist"
          
          # Transfer configuration files
          echo "üì¶ Transferring configuration files..."
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 -C -i ~/.ssh/ec2_key .env package.json pnpm-lock.yaml ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/
          
          # Compress and transfer dist directory
          echo "üì¶ Compressing and transferring built code..."
          tar -czf dist.tar.gz dist/
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 -i ~/.ssh/ec2_key dist.tar.gz ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/
          
          # Compress and transfer node_modules directory
          echo "üì¶ Compressing and transferring node_modules..."
          tar -czf node_modules.tar.gz node_modules/
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 -i ~/.ssh/ec2_key node_modules.tar.gz ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/
          
          # Extract the archives on the server
          echo "üì¶ Extracting files on server..."
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} << 'EOF'
            cd /home/ubuntu/app
            tar -xzf dist.tar.gz
            tar -xzf node_modules.tar.gz
            rm dist.tar.gz node_modules.tar.gz
          EOF
          
          echo "üì¶ Files deployed to EC2"

      - name: Configure and start application
        if: steps.terraform-apply.outcome == 'success'
        run: |
          # Use ssh directly instead of the action
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} << 'EOF'
            cd /home/ubuntu/app
            
            # Install newer version of Node.js
            echo "üîç Checking Node.js version..."
            NODE_VERSION=$(node -v)
            echo "Current Node.js version: $NODE_VERSION"
            
            if [[ "$NODE_VERSION" != "v18"* ]]; then
              echo "üì¶ Installing Node.js 18 LTS..."
              sudo apt update
              curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
              sudo apt install -y nodejs
              echo "‚úÖ Node.js $(node -v) installed"
            fi
            
            # Install PM2 globally
            if ! command -v pm2 &> /dev/null; then
              echo "üì¶ Installing PM2..."
              sudo npm install -g pm2
            fi
            
            # Stop the application if it's running
            echo "üîÑ Restarting application..."
            pm2 stop cerberes || echo "ü§ñ App not running"
            
            # Start the application with more detailed logging
            echo "üöÄ Starting application..."
            pm2 start dist/src/server.js --name cerberes --log-date-format 'YYYY-MM-DD HH:mm:ss.SSS' --merge-logs
            pm2 save
            
            # Check if the application started successfully
            sleep 5
            if pm2 show cerberes | grep -q "status.*online"; then
              echo "‚úÖ Application started successfully!"
            else
              echo "‚ùå Application failed to start. Checking logs..."
              pm2 logs cerberes --lines 50
              exit 1
            fi
            
            # Configure PM2 to start on boot
            echo "üîÑ Setting up PM2 to start on boot..."
            pm2 startup | grep "sudo" | bash || echo "‚ö†Ô∏è PM2 startup command failed, but continuing..."
            pm2 save
            
            # Verify the application is running and listening on port 3000
            echo "üîç Verifying application status..."
            pm2 list
            
            # Check if the application is listening on port 3000
            if command -v netstat &> /dev/null; then
              if netstat -tulpn 2>/dev/null | grep -q ":3000"; then
                echo "‚úÖ Application is listening on port 3000"
              else
                echo "‚ö†Ô∏è Application may not be listening on port 3000"
                netstat -tulpn | grep node
              fi
            else
              echo "‚ö†Ô∏è netstat not available, installing net-tools..."
              sudo apt-get update
              sudo apt-get install -y net-tools
              if netstat -tulpn | grep -q ":3000"; then
                echo "‚úÖ Application is listening on port 3000"
              else
                echo "‚ö†Ô∏è Application may not be listening on port 3000"
                netstat -tulpn | grep node
              fi
            fi
            
            echo "üöÄ Deployment completed"
          EOF
            
      - name: Cleanup on failure
        if: failure() && steps.terraform-apply.outcome == 'failure'
        working-directory: ./terraform
        run: |
          echo "üßπ Cleaning up failed deployment..."
          terraform destroy -auto-approve
          echo "‚ôªÔ∏è Resources cleaned up."
