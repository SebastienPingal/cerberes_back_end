name: AWS Deployment Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    branches: [master]
    types:
      - completed

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Debug step to check secrets are available (values will be masked)
      - name: Debug Secret Presence
        run: |
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then 
            echo "AWS_ACCESS_KEY_ID is set ‚úÖ"
          else
            echo "AWS_ACCESS_KEY_ID is NOT set ‚ùå"
          fi
          
          if [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then 
            echo "AWS_SECRET_ACCESS_KEY is set ‚úÖ"
          else
            echo "AWS_SECRET_ACCESS_KEY is NOT set ‚ùå"  
          fi
          
          if [ -n "${{ secrets.AWS_REGION }}" ]; then 
            echo "AWS_REGION is set ‚úÖ"
          else
            echo "AWS_REGION is NOT set ‚ùå"
          fi
          
          if [ -n "${{ secrets.JWT_SECRET }}" ]; then 
            echo "JWT_SECRET is set ‚úÖ"
          else
            echo "JWT_SECRET is NOT set ‚ùå"
            echo "‚ö†Ô∏è JWT_SECRET is required for the application to function properly"
          fi
          
          if [ -n "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then 
            echo "EC2_SSH_PRIVATE_KEY is set ‚úÖ"
            # Check if the key starts with the correct format
            if [[ "${{ secrets.EC2_SSH_PRIVATE_KEY }}" == "-----BEGIN"* ]]; then
              echo "SSH key appears to be in the correct format ‚úÖ"
            else
              echo "SSH key does not start with '-----BEGIN' - may be incorrectly formatted ‚ùå"
            fi
          else
            echo "EC2_SSH_PRIVATE_KEY is NOT set ‚ùå"
          fi

      # Build the app directly instead of trying to download an artifact
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8.6.0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install

      - name: Build application
        run: pnpm build

      - name: Prepare for production
        run: |
          # Prune development dependencies to keep only production dependencies
          echo "üì¶ Pruning dependencies for production..."
          pnpm prune --prod

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create terraform.tfvars
        run: |
          cat > terraform/terraform.tfvars << EOF
          aws_region      = "${{ secrets.AWS_REGION }}"
          app_name        = "cerberes"
          db_username     = "${{ secrets.DB_USERNAME }}"
          db_password     = "${{ secrets.DB_PASSWORD }}"
          ssh_key_name    = "${{ secrets.SSH_KEY_NAME }}"
          ec2_instance_type = "t2.micro"
          db_instance_class = "db.t3.micro"
          security_group_id = ""  # Will be populated by the next step if it exists
          EOF
          
          echo "üîë Created terraform.tfvars with database credentials"

      # Check for existing resources and modify Terraform code accordingly
      - name: Check for existing resources
        id: check-resources
        run: |
          # Get the default VPC ID for security group checks
          DEFAULT_VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query "Vpcs[0].VpcId" --output text)
          echo "DEFAULT_VPC_ID=$DEFAULT_VPC_ID" >> $GITHUB_ENV
          
          # Check if we have existing VPCs
          VPC_COUNT=$(aws ec2 describe-vpcs --query "length(Vpcs)" --output text)
          
          if [ "$VPC_COUNT" -gt "0" ]; then
            echo "VPC_EXISTS=true" >> $GITHUB_ENV
            echo "‚úÖ VPCs exist - will use existing ones"
            sed -i '/data "aws_vpcs" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/main.tf
          else
            echo "VPC_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï No VPCs exist - will use default VPC"
          fi
          
          # Use a single security group for both EC2 and RDS
          CERBERES_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=cerberes-sg" "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
          
          # Also check for the EC2-specific security group that might be in use
          EC2_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=cerberes-ec2-sg" "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
          
          # Check for RDS security group
          DB_SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=cerberes-db-sg" "Name=vpc-id,Values=$DEFAULT_VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
          
          # Store all security group IDs
          if [ "$EC2_SG_ID" != "None" ]; then
            echo "EC2_SG_EXISTS=true" >> $GITHUB_ENV
            echo "EC2_SG_ID=$EC2_SG_ID" >> $GITHUB_ENV
            echo "‚úÖ EC2 Security Group exists: $EC2_SG_ID"
          fi
          
          if [ "$DB_SG_ID" != "None" ]; then
            echo "DB_SG_EXISTS=true" >> $GITHUB_ENV
            echo "DB_SG_ID=$DB_SG_ID" >> $GITHUB_ENV
            echo "‚úÖ DB Security Group exists: $DB_SG_ID"
          fi
          
          if [ "$CERBERES_SG_ID" != "None" ]; then
            echo "SG_EXISTS=true" >> $GITHUB_ENV
            echo "CERBERES_SG_ID=$CERBERES_SG_ID" >> $GITHUB_ENV
            echo "‚úÖ Cerberes Security Group exists - will use existing one: $CERBERES_SG_ID"
            
            # Store the security group ID for Terraform
            echo "TF_VAR_security_group_id=$CERBERES_SG_ID" >> $GITHUB_ENV
            
            # Update the terraform.tfvars file with the security group ID
            sed -i "s/security_group_id = \"\"/security_group_id = \"$CERBERES_SG_ID\"/g" terraform/terraform.tfvars
          else
            echo "SG_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï Cerberes Security Group does not exist - will create new one"
            
            # Create a single security group for both EC2 and RDS
            echo "üîß Creating Cerberes security group..."
            CERBERES_SG_ID=$(aws ec2 create-security-group \
              --group-name cerberes-sg \
              --description "Security group for Cerberes application" \
              --vpc-id $DEFAULT_VPC_ID \
              --query "GroupId" --output text)
            
            if [ -z "$CERBERES_SG_ID" ] || [ "$CERBERES_SG_ID" == "None" ]; then
              echo "‚ùå Failed to create security group"
              exit 1
            fi
            
            # Add SSH access
            echo "üîß Adding SSH access rule..."
            aws ec2 authorize-security-group-ingress \
              --group-id $CERBERES_SG_ID \
              --protocol tcp \
              --port 22 \
              --cidr 0.0.0.0/0 || echo "‚ö†Ô∏è SSH rule couldn't be added"
              
            # Add HTTP access
            echo "üîß Adding HTTP access rule..."
            aws ec2 authorize-security-group-ingress \
              --group-id $CERBERES_SG_ID \
              --protocol tcp \
              --port 80 \
              --cidr 0.0.0.0/0 || echo "‚ö†Ô∏è HTTP rule couldn't be added"
              
            # Add application port access
            echo "üîß Adding application port access rule..."
            aws ec2 authorize-security-group-ingress \
              --group-id $CERBERES_SG_ID \
              --protocol tcp \
              --port 3000 \
              --cidr 0.0.0.0/0 || echo "‚ö†Ô∏è Application port rule couldn't be added"
              
            # Add PostgreSQL access within the security group
            echo "üîß Adding PostgreSQL access rule..."
            aws ec2 authorize-security-group-ingress \
              --group-id $CERBERES_SG_ID \
              --protocol tcp \
              --port 5432 \
              --source-group $CERBERES_SG_ID || echo "‚ö†Ô∏è PostgreSQL rule couldn't be added"
            
            echo "CERBERES_SG_ID=$CERBERES_SG_ID" >> $GITHUB_ENV
            echo "TF_VAR_security_group_id=$CERBERES_SG_ID" >> $GITHUB_ENV
            echo "‚úÖ Created Cerberes security group: $CERBERES_SG_ID"
            
            # Update the terraform.tfvars file with the security group ID
            sed -i "s/security_group_id = \"\"/security_group_id = \"$CERBERES_SG_ID\"/g" terraform/terraform.tfvars
          fi
          
          # Add cross-security group rules if both EC2 and DB security groups exist
          if [ "$EC2_SG_ID" != "None" ] && [ "$DB_SG_ID" != "None" ]; then
            echo "üîß Adding cross-security group rules..."
            
            # Allow EC2 to connect to RDS
            echo "üîß Adding rule to allow EC2 security group to access RDS security group..."
            aws ec2 authorize-security-group-ingress \
              --group-id $DB_SG_ID \
              --protocol tcp \
              --port 5432 \
              --source-group $EC2_SG_ID || echo "‚ö†Ô∏è EC2 to RDS rule already exists or couldn't be added"
              
            echo "‚úÖ Added cross-security group rules"
          fi
          
          # If we have both the unified security group and the EC2 security group, add rules between them
          if [ "$CERBERES_SG_ID" != "None" ] && [ "$EC2_SG_ID" != "None" ]; then
            echo "üîß Adding rules between unified and EC2 security groups..."
            
            # Allow EC2 security group to access the unified security group's PostgreSQL
            echo "üîß Adding rule to allow EC2 security group to access unified security group's PostgreSQL..."
            aws ec2 authorize-security-group-ingress \
              --group-id $CERBERES_SG_ID \
              --protocol tcp \
              --port 5432 \
              --source-group $EC2_SG_ID || echo "‚ö†Ô∏è EC2 to unified rule already exists or couldn't be added"
              
            echo "‚úÖ Added rules between unified and EC2 security groups"
          fi
          
          # If we have both the unified security group and the DB security group, add rules between them
          if [ "$CERBERES_SG_ID" != "None" ] && [ "$DB_SG_ID" != "None" ]; then
            echo "üîß Adding rules between unified and DB security groups..."
            
            # Allow unified security group to access the DB security group's PostgreSQL
            echo "üîß Adding rule to allow unified security group to access DB security group's PostgreSQL..."
            aws ec2 authorize-security-group-ingress \
              --group-id $DB_SG_ID \
              --protocol tcp \
              --port 5432 \
              --source-group $CERBERES_SG_ID || echo "‚ö†Ô∏è Unified to DB rule already exists or couldn't be added"
              
            echo "‚úÖ Added rules between unified and DB security groups"
          fi
          
          # Check if the security group has the required rules
          if [ "$CERBERES_SG_ID" != "None" ]; then
            echo "üîç Checking security group rules..."
            
            # Check for SSH rule
            SSH_RULE=$(aws ec2 describe-security-groups --group-id $CERBERES_SG_ID --query "SecurityGroups[0].IpPermissions[?FromPort==\`22\` && ToPort==\`22\`].IpRanges[?CidrIp==\`0.0.0.0/0\`].CidrIp" --output text)
            if [ -z "$SSH_RULE" ]; then
              echo "üîß Adding SSH access rule..."
              aws ec2 authorize-security-group-ingress \
                --group-id $CERBERES_SG_ID \
                --protocol tcp \
                --port 22 \
                --cidr 0.0.0.0/0 || echo "‚ö†Ô∏è SSH rule already exists or couldn't be added"
            else
              echo "‚úÖ SSH rule already exists"
            fi
            
            # Check for HTTP rule
            HTTP_RULE=$(aws ec2 describe-security-groups --group-id $CERBERES_SG_ID --query "SecurityGroups[0].IpPermissions[?FromPort==\`80\` && ToPort==\`80\`].IpRanges[?CidrIp==\`0.0.0.0/0\`].CidrIp" --output text)
            if [ -z "$HTTP_RULE" ]; then
              echo "üîß Adding HTTP access rule..."
              aws ec2 authorize-security-group-ingress \
                --group-id $CERBERES_SG_ID \
                --protocol tcp \
                --port 80 \
                --cidr 0.0.0.0/0 || echo "‚ö†Ô∏è HTTP rule already exists or couldn't be added"
            else
              echo "‚úÖ HTTP rule already exists"
            fi
            
            # Check for application port rule
            APP_RULE=$(aws ec2 describe-security-groups --group-id $CERBERES_SG_ID --query "SecurityGroups[0].IpPermissions[?FromPort==\`3000\` && ToPort==\`3000\`].IpRanges[?CidrIp==\`0.0.0.0/0\`].CidrIp" --output text)
            if [ -z "$APP_RULE" ]; then
              echo "üîß Adding application port access rule..."
              aws ec2 authorize-security-group-ingress \
                --group-id $CERBERES_SG_ID \
                --protocol tcp \
                --port 3000 \
                --cidr 0.0.0.0/0 || echo "‚ö†Ô∏è Application port rule already exists or couldn't be added"
            else
              echo "‚úÖ Application port rule already exists"
            fi
            
            # Check for PostgreSQL rule
            PG_RULE=$(aws ec2 describe-security-groups --group-id $CERBERES_SG_ID --query "SecurityGroups[0].IpPermissions[?FromPort==\`5432\` && ToPort==\`5432\`].UserIdGroupPairs[?GroupId==\`$CERBERES_SG_ID\`].GroupId" --output text)
            if [ -z "$PG_RULE" ]; then
              echo "üîß Adding PostgreSQL access rule..."
              aws ec2 authorize-security-group-ingress \
                --group-id $CERBERES_SG_ID \
                --protocol tcp \
                --port 5432 \
                --source-group $CERBERES_SG_ID || echo "‚ö†Ô∏è PostgreSQL rule already exists or couldn't be added"
            else
              echo "‚úÖ PostgreSQL rule already exists"
            fi
            
            echo "‚úÖ Security group rules verified"
          fi
          
          # Check if EC2 instances with the tag Name=cerberes-instance exist
          EC2_COUNT=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=cerberes-instance" "Name=instance-state-name,Values=running,stopped" --query "length(Reservations[*].Instances[*])" --output text)
          
          if [ "$EC2_COUNT" -gt "0" ]; then
            echo "EC2_INSTANCE_EXISTS=true" >> $GITHUB_ENV
            EC2_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=cerberes-instance" "Name=instance-state-name,Values=running,stopped" --query "Reservations[0].Instances[0].InstanceId" --output text)
            echo "‚úÖ EC2 Instance exists - will use existing one: $EC2_ID"
            # Modify the Terraform code to use the existing EC2 instance
            sed -i '/data "aws_instances" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/ec2.tf
          else
            echo "EC2_INSTANCE_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï EC2 Instance does not exist - will create new one"
          fi
          
          # Check if DB subnet group exists
          if aws rds describe-db-subnet-groups --db-subnet-group-name cerberes-db-subnet-group &> /dev/null; then
            echo "SUBNET_GROUP_EXISTS=true" >> $GITHUB_ENV
            echo "‚úÖ DB Subnet Group exists - will use existing one"
            # Modify the Terraform code to use the existing subnet group
            sed -i '/data "aws_db_subnet_group" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/rds.tf
          else
            echo "SUBNET_GROUP_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï DB Subnet Group does not exist - will create new one"
          fi
          
          # Check if DB instance exists
          if aws rds describe-db-instances --db-instance-identifier cerberes-db &> /dev/null; then
            echo "DB_INSTANCE_EXISTS=true" >> $GITHUB_ENV
            echo "‚úÖ DB Instance exists - will use existing one"
            # Modify the Terraform code to use the existing DB instance
            sed -i '/data "aws_db_instance" "existing" {/,/count =/ s/count = 0/count = 1/g' terraform/rds.tf
          else
            echo "DB_INSTANCE_EXISTS=false" >> $GITHUB_ENV
            echo "üÜï DB Instance does not exist - will create new one"
          fi

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Debug Terraform Variables
        working-directory: ./terraform
        run: |
          echo "üîç Checking terraform.auto.tfvars content:"
          cat terraform.auto.tfvars || echo "File not found"
          
          echo "üîç Environment variables for Terraform:"
          echo "TF_VAR_existing_ec2_sg_id: $TF_VAR_existing_ec2_sg_id"
          echo "TF_VAR_existing_db_sg_id: $TF_VAR_existing_db_sg_id"
          echo "TF_VAR_security_group_id: $TF_VAR_security_group_id"

      - name: Terraform Apply
        id: terraform-apply
        working-directory: ./terraform
        run: terraform apply -auto-approve

      # Get EC2 public IP directly from AWS CLI instead of Terraform output
      - name: Get EC2 public IP
        if: steps.terraform-apply.outcome == 'success'
        id: ec2_ip
        run: |
          # Get the EC2 instance ID
          EC2_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=cerberes-instance" "Name=instance-state-name,Values=running" --query "Reservations[0].Instances[0].InstanceId" --output text)
          
          # Get the public IP directly from AWS CLI
          IP_ADDRESS=$(aws ec2 describe-instances --instance-ids $EC2_ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          
          # Set the environment variable for use in subsequent steps
          echo "EC2_IP=$IP_ADDRESS" >> $GITHUB_ENV
          
          echo "üñ•Ô∏è EC2 instance public IP: $IP_ADDRESS"

      # Get RDS endpoint directly from AWS CLI instead of Terraform output
      - name: Get RDS endpoint
        if: steps.terraform-apply.outcome == 'success'
        id: rds_endpoint
        run: |
          # Get the RDS endpoint directly from AWS CLI
          DB_ENDPOINT=$(aws rds describe-db-instances --db-instance-identifier cerberes-db --query "DBInstances[0].Endpoint.Address" --output text)
          
          # Set the environment variable for use in subsequent steps
          echo "DB_ENDPOINT=$DB_ENDPOINT" >> $GITHUB_ENV
          
          echo "üóÑÔ∏è RDS endpoint: $DB_ENDPOINT"

      # Add a delay to ensure EC2 instance is fully initialized
      - name: Wait for EC2 instance to initialize
        if: steps.terraform-apply.outcome == 'success'
        run: |
          echo "‚è≥ Waiting 60 seconds for EC2 instance to fully initialize..."
          sleep 60

      # Create a temporary SSH key file
      - name: Setup SSH key
        if: steps.terraform-apply.outcome == 'success'
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key
          echo "üîë SSH key file created"
          
          # Test SSH connection
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} "echo SSH connection test successful"

      - name: Deploy application to EC2
        if: steps.terraform-apply.outcome == 'success'
        run: |
          # Create .env file for deployment
          cat > .env << EOF
          NODE_ENV=production
          DATABASE_URL=postgres://${{ secrets.DB_USERNAME }}:${{ secrets.DB_PASSWORD }}@${{ env.DB_ENDPOINT }}/cerberes
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          PORT=3000
          EOF
          
          # Create app directory on the server if it doesn't exist
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} "mkdir -p /home/ubuntu/app"
          
          echo "üßπ Cleaning up old files on server to free space..."
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} "rm -rf /home/ubuntu/app/node_modules /home/ubuntu/app/dist"
          
          # Transfer configuration files
          echo "üì¶ Transferring configuration files..."
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 -C -i ~/.ssh/ec2_key .env package.json pnpm-lock.yaml ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/
          
          # Compress and transfer dist directory
          echo "üì¶ Compressing and transferring built code..."
          tar -czf dist.tar.gz dist/
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 -i ~/.ssh/ec2_key dist.tar.gz ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/
          
          # Compress and transfer node_modules directory
          echo "üì¶ Compressing and transferring node_modules..."
          tar -czf node_modules.tar.gz node_modules/
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 -i ~/.ssh/ec2_key node_modules.tar.gz ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/
          
          # Extract the archives on the server
          echo "üì¶ Extracting files on server..."
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} << 'EOF'
            cd /home/ubuntu/app
            tar -xzf dist.tar.gz
            tar -xzf node_modules.tar.gz
            rm dist.tar.gz node_modules.tar.gz
            
            # Verify the .env file is properly formatted (no line breaks in values)
            echo "üîç Verifying .env file format..."
            if grep -q "DATABASE_URL=.*\n.*" .env; then
              echo "‚ö†Ô∏è Found line breaks in DATABASE_URL, fixing..."
              # Fix the .env file by ensuring each variable is on a single line
              awk -F= '{if(NR==1) {printf "%s=%s\n",$1,$2} else {printf "%s=%s\n",$1,$2}}' .env > .env.fixed
              mv .env.fixed .env
            fi
            
            echo "‚úÖ .env file verified"
          EOF
          
          echo "üì¶ Files deployed to EC2"

      - name: Configure and start application
        if: steps.terraform-apply.outcome == 'success'
        run: |
          # Use ssh directly instead of the action
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -i ~/.ssh/ec2_key ubuntu@${{ env.EC2_IP }} << 'EOF'
            cd /home/ubuntu/app
            
            # Install newer version of Node.js
            echo "üîç Checking Node.js version..."
            NODE_VERSION=$(node -v)
            echo "Current Node.js version: $NODE_VERSION"
            
            if [[ "$NODE_VERSION" != "v18"* ]]; then
              echo "üì¶ Installing Node.js 18 LTS..."
              sudo apt update
              curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
              sudo apt install -y nodejs
              echo "‚úÖ Node.js $(node -v) installed"
            fi
            
            # Install PM2 globally
            if ! command -v pm2 &> /dev/null; then
              echo "üì¶ Installing PM2..."
              sudo npm install -g pm2
            fi
            
            # Install PostgreSQL client for testing database connection
            if ! command -v psql &> /dev/null; then
              echo "üì¶ Installing PostgreSQL client..."
              sudo apt-get update
              sudo apt-get install -y postgresql-client
            fi
            
            # Test database connection
            echo "üîç Testing database connection..."
            DB_URL=$(grep DATABASE_URL .env | cut -d= -f2-)
            DB_HOST=$(echo $DB_URL | sed -n 's/.*@\(.*\)\/.*/\1/p')
            DB_USER=$(echo $DB_URL | sed -n 's/postgres:\/\/\(.*\):.*/\1/p')
            DB_PASSWORD=$(echo $DB_URL | sed -n 's/postgres:\/\/.*:\(.*\)@.*/\1/p')
            DB_NAME=$(echo $DB_URL | sed -n 's/.*\/\(.*\)/\1/p')
            
            echo "üîç Database host: $DB_HOST"
            echo "üîç Database user: $DB_USER"
            echo "üîç Database name: $DB_NAME"
            
            # Get instance metadata for debugging
            INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
            PRIVATE_IP=$(curl -s http://169.254.169.254/latest/meta-data/local-ipv4)
            SECURITY_GROUPS=$(curl -s http://169.254.169.254/latest/meta-data/security-groups)
            
            echo "üîç EC2 Instance ID: $INSTANCE_ID"
            echo "üîç EC2 Private IP: $PRIVATE_IP"
            echo "üîç EC2 Security Groups: $SECURITY_GROUPS"
            
            # Install AWS CLI if not available
            if ! command -v aws &> /dev/null; then
              echo "üì¶ Installing AWS CLI..."
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              sudo apt-get install -y unzip
              unzip awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
            fi
            
            # Configure AWS CLI with instance profile credentials
            echo "üîß Configuring AWS CLI with instance profile credentials..."
            TOKEN=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
            REGION=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
            echo "üîç Region: $REGION"
            
            # Get the security group IDs
            echo "üîß Getting security group IDs..."
            MAC=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/mac)
            VPC_ID=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/$MAC/vpc-id)
            echo "üîç VPC ID: $VPC_ID"
            
            # Get EC2 security group ID
            EC2_SG_NAME=$(curl -s -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/security-groups)
            EC2_SG_ID=$(aws ec2 describe-security-groups --region $REGION --filters "Name=group-name,Values=$EC2_SG_NAME" "Name=vpc-id,Values=$VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
            echo "üîç EC2 Security Group ID: $EC2_SG_ID"
            
            # Get RDS security group ID
            DB_HOST_SHORT=$(echo $DB_HOST | cut -d'.' -f1)
            DB_SG_NAME="${DB_HOST_SHORT}-sg"
            echo "üîç Looking for RDS security group with name pattern: *${DB_HOST_SHORT}*"
            
            # Try to find the RDS security group
            DB_SG_ID=$(aws ec2 describe-security-groups --region $REGION --filters "Name=group-name,Values=*${DB_HOST_SHORT}*,*rds*,*db*" "Name=vpc-id,Values=$VPC_ID" --query "SecurityGroups[0].GroupId" --output text)
            if [ "$DB_SG_ID" == "None" ]; then
              echo "‚ö†Ô∏è Could not find RDS security group by name pattern"
              # Try to find by looking at the DB instance
              DB_IDENTIFIER=$(echo $DB_HOST_SHORT | sed 's/-db$//')
              echo "üîç Looking for RDS instance with identifier: $DB_IDENTIFIER"
              DB_SG_ID=$(aws rds describe-db-instances --region $REGION --db-instance-identifier $DB_IDENTIFIER --query "DBInstances[0].VpcSecurityGroups[0].VpcSecurityGroupId" --output text 2>/dev/null || echo "None")
            fi
            
            echo "üîç RDS Security Group ID: $DB_SG_ID"
            
            # Add rule to allow EC2 to connect to RDS if both security groups were found
            if [ "$EC2_SG_ID" != "None" ] && [ "$DB_SG_ID" != "None" ] && [ "$DB_SG_ID" != "" ]; then
              echo "üîß Adding rule to allow EC2 security group to access RDS security group..."
              aws ec2 authorize-security-group-ingress --region $REGION \
                --group-id $DB_SG_ID \
                --protocol tcp \
                --port 5432 \
                --source-group $EC2_SG_ID || echo "‚ö†Ô∏è Rule already exists or couldn't be added"
              
              echo "‚úÖ Added rule to allow EC2 to connect to RDS"
            else
              echo "‚ö†Ô∏è Could not add security group rule - missing security group IDs"
            fi
            
            # Test connection with timeout
            if PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1" -t -A -w -q; then
              echo "‚úÖ Database connection successful!"
            else
              echo "‚ùå Database connection failed!"
              echo "‚ö†Ô∏è Checking network connectivity to database..."
              nc -zv "$DB_HOST" 5432 || echo "‚ùå Cannot connect to database port"
              echo "‚ö†Ô∏è Checking security group rules..."
              curl -s http://169.254.169.254/latest/meta-data/security-groups
              echo ""
              curl -s http://169.254.169.254/latest/meta-data/local-ipv4
              echo ""
            fi
            
            # Stop the application if it's running
            echo "üîÑ Restarting application..."
            pm2 stop cerberes || echo "ü§ñ App not running"
            
            # Start the application with more detailed logging
            echo "üöÄ Starting application..."
            pm2 start dist/src/server.js --name cerberes --log-date-format 'YYYY-MM-DD HH:mm:ss.SSS' --merge-logs
            pm2 save
            
            # Check if the application started successfully
            sleep 5
            if pm2 show cerberes | grep -q "status.*online"; then
              echo "‚úÖ Application started successfully!"
            else
              echo "‚ùå Application failed to start. Checking logs..."
              pm2 logs cerberes --lines 50
              exit 1
            fi
            
            # Configure PM2 to start on boot
            echo "üîÑ Setting up PM2 to start on boot..."
            pm2 startup | grep "sudo" | bash || echo "‚ö†Ô∏è PM2 startup command failed, but continuing..."
            pm2 save
            
            # Verify the application is running and listening on port 3000
            echo "üîç Verifying application status..."
            pm2 list
            
            # Check if the application is listening on port 3000
            if command -v netstat &> /dev/null; then
              if netstat -tulpn 2>/dev/null | grep -q ":3000"; then
                echo "‚úÖ Application is listening on port 3000"
              else
                echo "‚ö†Ô∏è Application may not be listening on port 3000"
                netstat -tulpn | grep node
              fi
            else
              echo "‚ö†Ô∏è netstat not available, installing net-tools..."
              sudo apt-get update
              sudo apt-get install -y net-tools
              if netstat -tulpn | grep -q ":3000"; then
                echo "‚úÖ Application is listening on port 3000"
              else
                echo "‚ö†Ô∏è Application may not be listening on port 3000"
                netstat -tulpn | grep node
              fi
            fi
            
            echo "üöÄ Deployment completed"
          EOF
            
      - name: Cleanup on failure
        if: failure() && steps.terraform-apply.outcome == 'failure'
        working-directory: ./terraform
        run: |
          echo "üßπ Cleaning up failed deployment..."
          terraform destroy -auto-approve
          echo "‚ôªÔ∏è Resources cleaned up."
